<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Código de Hamming - Codificador y Detector de Errores</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        input[type="text"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
        }

        input[type="text"]:focus {
            border-color: #4CAF50;
            outline: none;
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin: 15px 0;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        input[type="radio"] {
            margin: 0;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        #clearBtn:hover {
            background-color: #e64a19;
        }

        .result {
            margin-top: 30px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 5px;
            border: 1px solid #ddd;
        }

        .error {
            color: #d32f2f;
            background-color: #ffebee;
            border-color: #f8bbd9;
        }

        table {
            border-collapse: collapse;
            margin: 10px 0;
            width: 100%;
        }

        th, td {
            border: 1px solid #333;
            padding: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        th {
            background-color: #f0f0f0;
            font-weight: bold;
        }

        td.position {
            font-weight: bold;
        }

        .step {
            margin: 20px 0;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .step h4 {
            margin-top: 0;
            color: #333;
        }

        .highlight {
            background-color: #ffeb3b;
            font-weight: bold;
        }

        .error-row {
            background-color: #ffdddd;
        }

        .success-message {
            color: #2e7d32;
            font-weight: bold;
        }

        .binary-input {
            font-family: 'Courier New', monospace;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h1 style="margin: 0;">Código de Hamming</h1>
            <p style="margin: 0; font-style: italic; color: #666; font-size: 14px;">
                <strong>Autor:</strong> Unv. Jhasmany Fernandez Ortega
            </p>
        </div>
        <p>Ingrese una secuencia de bits binarios para codificar o una palabra codificada para detectar y corregir errores.</p>

        <form id="hammingForm">
            <div class="form-group">
                <label for="dataBits">Bits (ejemplo: 1011 para codificar, 1010101 para detectar/corregir):</label>
                <input type="text" id="dataBits" name="dataBits" pattern="[01]+" required
                       placeholder="Ingrese solo 1s y 0s" class="binary-input">
            </div>

            <div class="form-group">
                <label>Seleccione la acción:</label>
                <div class="radio-group">
                    <div class="radio-option">
                        <input type="radio" id="encode" name="action" value="encode" checked>
                        <label for="encode">Codificar (agregar bits de paridad)</label>
                    </div>
                    <div class="radio-option">
                        <input type="radio" id="decode" name="action" value="decode">
                        <label for="decode">Detectar y Corregir errores</label>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button type="submit">Procesar</button>
                <button type="button" id="clearBtn" style="background-color: #ff5722;">Limpiar Todo</button>
            </div>
        </form>

        <div id="result" class="result" style="display: none;"></div>
    </div>

    <script>
        // Funciones del código de Hamming convertidas de TypeScript
        function calculateParityBits(m) {
            let r = 1;
            while (Math.pow(2, r) < m + r + 1) {
                r++;
            }
            return r;
        }

        function isPowerOfTwo(x) {
            return (x & (x - 1)) === 0 && x !== 0;
        }

        function encodeHamming(data) {
            const m = data.length;
            const r = calculateParityBits(m);
            const n = m + r;

            const code = Array(n).fill(0);
            let dataPos = 0;

            // Colocar bits de datos
            for (let i = 0; i < n; i++) {
                if (!isPowerOfTwo(i + 1)) {
                    code[i] = data[dataPos++];
                }
            }

            // Calcular bits de paridad
            for (let i = 0; i < r; i++) {
                const parityPos = Math.pow(2, i);
                let parity = 0;

                for (let j = 1; j <= n; j++) {
                    if ((j & parityPos) && j !== parityPos) {
                        parity ^= code[j - 1];
                    }
                }
                code[parityPos - 1] = parity;
            }

            return code;
        }

        function detectAndCorrect(code) {
            const n = code.length;
            let r = 0;
            while (Math.pow(2, r) < n + 1) {
                r++;
            }

            let syndrome = 0;
            for (let i = 0; i < r; i++) {
                const parityPos = Math.pow(2, i);
                let parity = 0;

                for (let j = 1; j <= n; j++) {
                    if (j & parityPos) {
                        parity ^= code[j - 1];
                    }
                }

                if (parity !== 0) {
                    syndrome |= parityPos;
                }
            }

            if (syndrome === 0) {
                return [null, "No se detectó ningún error."];
            } else if (syndrome <= n) {
                const correctedCode = [...code];
                correctedCode[syndrome - 1] ^= 1;
                return [correctedCode, `Error detectado en la posición ${syndrome}. Palabra corregida: ${correctedCode.join("")}`];
            } else {
                return [null, "Error detectado, pero no se puede corregir (síndrome inválido)."];
            }
        }

        function generateHammingMatrixTableDetailed(dataBits) {
            const m = dataBits.length;
            const r = calculateParityBits(m);
            const n = m + r;

            const code = Array(n).fill(0);
            let dataPos = 0;

            for (let i = 0; i < n; i++) {
                if (!isPowerOfTwo(i + 1)) {
                    code[i] = dataBits[dataPos++];
                }
            }

            function getControlledPositions(parityPos) {
                let positions = [];
                for (let pos = 1; pos <= n; pos++) {
                    if ((pos & parityPos) !== 0) {
                        positions.push(pos);
                    }
                }
                return positions;
            }

            let html = `<h4>Estructura base</h4>`;
            html += `<table><thead><tr><th></th>`;
            for (let i = 1; i <= n; i++) {
                const binPos = i.toString(2).padStart(r, "0");
                if (isPowerOfTwo(i)) {
                    html += `<th>p<sub>${Math.log2(i) + 1}</sub><br>${binPos}<br>(${i})</th>`;
                } else {
                    html += `<th>d<sub>${i}</sub><br>${binPos}<br>(${i})</th>`;
                }
            }
            html += `</tr></thead><tbody>`;

            html += `<tr><td>Posición</td>`;
            for (let i = 1; i <= n; i++) {
                const binPos = i.toString(2).padStart(4, "0");
                html += `<td>${binPos}</td>`;
            }
            html += `</tr>`;

            html += `<tr><td>Palabra original</td>`;
            for (let i = 0; i < n; i++) {
                if (isPowerOfTwo(i + 1)) {
                    html += `<td></td>`;
                } else {
                    html += `<td>${code[i]}</td>`;
                }
            }
            html += `</tr></tbody></table>`;

            for (let i = 0; i < r; i++) {
                const parityPos = Math.pow(2, i);
                const controlledPositions = getControlledPositions(parityPos);

                let onesCount = 0;
                for (const pos of controlledPositions) {
                    if (pos === parityPos) continue;
                    if (code[pos - 1] === 1) onesCount++;
                }

                const parity = (onesCount % 2 === 0) ? 0 : 1;
                code[parityPos - 1] = parity;

                html += `<div class="step"><h4>Cálculo bit paridad p<sub>${i + 1}</sub> (posición ${parityPos})</h4>`;
                html += `<table><thead><tr>`;
                for (let pos = 1; pos <= n; pos++) {
                    html += `<th>${pos}</th>`;
                }
                html += `<th>Paridad p<sub>${i + 1}</sub></th>`;
                html += `</tr></thead><tbody><tr>`;
                for (let pos = 1; pos <= n; pos++) {
                    if (controlledPositions.includes(pos)) {
                        html += `<td>${code[pos - 1]}</td>`;
                    } else {
                        html += `<td>&nbsp;</td>`;
                    }
                }
                html += `<td><b>${parity}</b></td>`;
                html += `</tr></tbody></table>`;
                html += `<p>Bit de paridad p<sub>${i + 1}</sub> colocado en posición ${parityPos} con valor ${parity}.</p>`;
                html += `</div>`;
            }

            html += `<h3>Palabra codificada completa</h3>`;
            html += `<table><thead><tr><th></th>`;
            for (let i = 1; i <= n; i++) {
                const binPos = i.toString(2).padStart(r, "0");
                if (isPowerOfTwo(i)) {
                    html += `<th>p<sub>${Math.log2(i) + 1}</sub><br>${binPos}<br>(${i})</th>`;
                } else {
                    html += `<th>d<sub>${i}</sub><br>${binPos}<br>(${i})</th>`;
                }
            }
            html += `</tr></thead><tbody>`;

            html += `<tr><td>Posición</td>`;
            for (let i = 1; i <= n; i++) {
                const binPos = i.toString(2).padStart(4, "0");
                html += `<td>${binPos}</td>`;
            }
            html += `</tr>`;

            html += `<tr><td>Palabra original</td>`;
            for (let i = 0; i < n; i++) {
                if (isPowerOfTwo(i + 1)) {
                    html += `<td></td>`;
                } else {
                    html += `<td>${code[i]}</td>`;
                }
            }
            html += `</tr>`;

            for (let i = 0; i < r; i++) {
                const parityPos = Math.pow(2, i);
                const controlledPositions = getControlledPositions(parityPos);

                html += `<tr><td>p<sub>${i + 1}</sub></td>`;
                for (let pos = 1; pos <= n; pos++) {
                    if (pos === parityPos) {
                        html += `<td><b>${code[pos - 1]}</b></td>`;
                    } else if (controlledPositions.includes(pos)) {
                        html += `<td>${code[pos - 1]}</td>`;
                    } else {
                        html += `<td></td>`;
                    }
                }
                html += `</tr>`;
            }

            html += `<tr><td>Palabra+paridad</td>`;
            for (let i = 0; i < n; i++) {
                html += `<td>${code[i]}</td>`;
            }
            html += `</tr></tbody></table>`;

            return html;
        }

        function generateHammingDecodeTableDetailed(code) {
            const n = code.length;
            let r = 0;
            while (Math.pow(2, r) < n + 1) {
                r++;
            }

            function getControlledPositions(parityPos) {
                let positions = [];
                for (let pos = 1; pos <= n; pos++) {
                    if ((pos & parityPos) !== 0) {
                        positions.push(pos);
                    }
                }
                return positions;
            }

            let syndrome = 0;
            const parityChecks = [];

            for (let i = 0; i < r; i++) {
                const parityPos = Math.pow(2, i);

                let parityExpected = 0;
                for (let pos = 1; pos <= n; pos++) {
                    if ((pos & parityPos) !== 0 && pos !== parityPos) {
                        parityExpected ^= code[pos - 1];
                    }
                }

                const storedParity = code[parityPos - 1];
                const checkOk = parityExpected === storedParity;
                if (!checkOk) {
                    syndrome |= parityPos;
                }
                parityChecks.push({
                    parityPos,
                    parityCalc: parityExpected,
                    storedParity,
                    checkResult: checkOk ? "OK (0)" : "Error (1)",
                });
            }

            let html = `<h4>Palabra recibida</h4>`;
            html += `<table><thead><tr><th>Posición</th>`;
            for (let i = 1; i <= n; i++) {
                html += `<th>${i}</th>`;
            }
            html += `</tr></thead><tbody><tr><td>Bits</td>`;
            for (let i = 0; i < n; i++) {
                html += `<td>${code[i]}</td>`;
            }
            html += `</tr></tbody></table>`;

            html += `<h4>Cálculo y verificación de bits de paridad</h4>`;
            html += `<table><thead><tr><th>Paridad</th>`;
            for (let i = 1; i <= n; i++) {
                html += `<th>${i}</th>`;
            }
            html += `<th>Paridad calculada</th><th>Paridad almacenada</th><th>Comprobación</th><th>Unos en bits controlados</th></tr></thead><tbody>`;

            for (const { parityPos, parityCalc, storedParity, checkResult } of parityChecks) {
                const controlledPositions = getControlledPositions(parityPos);

                let onesCount = 0;
                for (const pos of controlledPositions) {
                    if (pos !== parityPos && code[pos - 1] === 1) {
                        onesCount++;
                    }
                }

                const rowStyle = checkResult.startsWith("Error") ? ' class="error-row"' : "";

                html += `<tr${rowStyle}><td>p<sub>${Math.log2(parityPos) + 1}</sub></td>`;

                for (let pos = 1; pos <= n; pos++) {
                    if (controlledPositions.includes(pos)) {
                        if (pos === parityPos) {
                            html += `<td><b>${parityCalc}</b></td>`;
                        } else {
                            html += `<td>${code[pos - 1]}</td>`;
                        }
                    } else {
                        html += `<td></td>`;
                    }
                }

                html += `<td><b>${parityCalc}</b></td><td><b>${storedParity}</b></td><td>${checkResult}</td><td>${onesCount} unos</td></tr>`;
            }

            html += `</tbody></table>`;

            html += `<h4>Síndrome y corrección</h4>`;
            if (syndrome === 0) {
                html += `<p class="success-message">No se detectó ningún error. Síndrome = 0</p>`;
            } else if (syndrome <= n) {
                html += `<p>Error detectado en la posición <b>${syndrome}</b>.</p>`;
                const correctedCode = [...code];
                correctedCode[syndrome - 1] ^= 1;
                html += `<p>Palabra corregida: <b>${correctedCode.join("")}</b></p>`;

                html += `<table><thead><tr><th>Posición</th>`;
                for (let i = 1; i <= n; i++) {
                    html += `<th>${i}</th>`;
                }
                html += `</tr></thead><tbody><tr><td>Bits corregidos</td>`;
                for (let i = 0; i < n; i++) {
                    html += `<td>${correctedCode[i]}</td>`;
                }
                html += `</tr></tbody></table>`;

                const dataBitsOnly = correctedCode.filter((_, i) => !isPowerOfTwo(i + 1));
                html += `<p>Bits de datos extraídos: <b>${dataBitsOnly.join("")}</b></p>`;

            } else {
                html += `<p>Error detectado, pero el síndrome no es válido para corrección.</p>`;
            }

            return html;
        }

        // Manejo del formulario
        document.getElementById('hammingForm').addEventListener('submit', function(e) {
            e.preventDefault();

            const dataBits = document.getElementById('dataBits').value.trim();
            const action = document.querySelector('input[name="action"]:checked').value;
            const resultDiv = document.getElementById('result');

            // Validación
            if (!dataBits || !/^[01]+$/.test(dataBits)) {
                resultDiv.innerHTML = '<p class="error">Error: Debe ingresar una cadena binaria válida (solo 1s y 0s).</p>';
                resultDiv.style.display = 'block';
                return;
            }

            let html = `<h2>Proceso Código Hamming</h2>`;
            html += `<p><b>Bits ingresados:</b> ${dataBits}</p>`;

            try {
                if (action === 'encode') {
                    const data = dataBits.split('').map(Number);
                    const tableHtml = generateHammingMatrixTableDetailed(data);
                    html += `<h3>Codificación paso a paso detallada</h3>`;
                    html += tableHtml;

                } else if (action === 'decode') {
                    const code = dataBits.split('').map(Number);

                    if (code.length < 3) {
                        resultDiv.innerHTML = '<p class="error">Error: La palabra codificada es demasiado corta para procesar.</p>';
                        resultDiv.style.display = 'block';
                        return;
                    }

                    const tableHtml = generateHammingDecodeTableDetailed(code);
                    html += `<h3>Detección y corrección paso a paso</h3>`;
                    html += tableHtml;
                }

                resultDiv.innerHTML = html;
                resultDiv.className = 'result';
                resultDiv.style.display = 'block';

            } catch (error) {
                resultDiv.innerHTML = `<p class="error">Error al procesar: ${error.message}</p>`;
                resultDiv.style.display = 'block';
            }
        });

        // Validación en tiempo real del input
        document.getElementById('dataBits').addEventListener('input', function(e) {
            const value = e.target.value;
            if (value && !/^[01]*$/.test(value)) {
                e.target.setCustomValidity('Solo se permiten 1s y 0s');
            } else {
                e.target.setCustomValidity('');
            }
        });

        // Botón limpiar todo
        document.getElementById('clearBtn').addEventListener('click', function() {
            // Limpiar el campo de entrada
            document.getElementById('dataBits').value = '';

            // Resetear validación
            document.getElementById('dataBits').setCustomValidity('');

            // Seleccionar opción "Codificar" por defecto
            document.getElementById('encode').checked = true;

            // Ocultar resultados
            const resultDiv = document.getElementById('result');
            resultDiv.style.display = 'none';
            resultDiv.innerHTML = '';

            // Enfocar el campo de entrada
            document.getElementById('dataBits').focus();
        });
    </script>
</body>
</html>